[{"title":"C语言实现base64加密","date":"2022-04-28T11:52:00.000Z","url":"/2022/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E5%8A%A0%E5%AF%86/","categories":[["undefined",""]],"content":"一.程序目的使用c/c++完成以下下算法: 输入一个字符串，检查该字符串总ascii码值。如果值大于1000则对该字符串进行base64加密输出，否则该字符串与base64编码表进行异或输出 二.程序代码代码如下： 三.程序分析1.这里先说一下base64加密 通常一个字节是8位，而base64加密是使这些8位的变为6位，就比如说“ABC”对应的二进制： 01000001 01000010 01000011 转为六位就是：（010000） （010100）（001001）（000011） 而正是其最多只有六位，2的6次方=64，base64由此得名，且base64编码表中总共有64个字符，如下表 通过上表，base64加密“ABC”得：QUJD 若有两个字符，比如“12”的二进制：00110001 00110010 转为六位一组就是 001100 010011 001000（不够自动补0） 本来按这样的规律base64加密是：MTI 但像这种2%3=2的字符串长度，需要再补上‘=’，也就是最后的加密结果是：MTI= 若字符串长度为1，也就是1%3=1，需要在加密过后再补上两个‘=’； 2.代码分析 这一段主要是初始化数组，输入字符串并计算字符串的ASCII值 这一段是对输入的字符串进行base64加密 for循环理论不知道该咋说，只能举个栗子， 比如输入ABC，对应的二进制也就是：01000001 01000010 01000011，让第一组二进制左移两位，也就是010000，得到第一组六位base 010000； 然后再让01000001与0x3（也就是11）进行与运算，也就把01000001的后两位提出来，然后左移四位也就得到010000，就是第二组base的前两位，再与右移四位的01000010（即0100）进行或运算，得到第二组六位base 010100； 第三组base就是让01000010&amp;0xf（也就是1111）得到0010接着左移两位得到001000，01000011右移两位得到01，001000|01得到第三组base 001001； 第四组base就01000011&amp;0x3f（也就是111111）得到000011 添加‘=’的这段代码，我也不会讲，也只能举个栗子 比如输入的字符串是‘1’，经过for循环之后，i的值为4，也就是y数组长度为5，但是从y[i-2]的值就是空的，所以添加‘=’要从y[i-2]开始赋值，由于y[i]里面没有存储值，所以数组长度就是4，而1%3=1，也符合上面的代码（感觉讲的好乱，不过我确实尽力了QAQ） ASCII值大于1000，作base64加密并输出 ASCII值小于1000，原字符串与base64编码表进行异或运算并输出 四.运行结果及验证程序运行结果： 在线base64加密验证： "},{"title":"BUUCTF MISC（随机基础八道题）","date":"2022-04-09T08:44:39.000Z","url":"/2022/04/09/BUUCTFMISC/","categories":[["undefined",""]],"content":"一、你竟然赶我走下载后是一个图片，直接用010editor打开，ctrl+F搜索flag，然后就出来了flag{stego_is_s0_bor1ing} 二、N种方法解决文件是一个exe，但无法打开，用010editor打开发现是base64转图片类型的字符串，这时可以直接复制这些东西用浏览器去打开也可以搜base64在线转换图片，得到的结果与上图一致，扫一下就出了flag{dca57f966e4e4e31fd5b15417da63269} 三、乌镇峰会种图直接用010editor打开，一搜flag就搜出来了 四、大白题目都说了图片小，那就把它调大些，这里把01改成08打开图片，得到flagflag{He1l0_d4_ba1} 五、二维码这道题主要考察对binwalk分离工具的使用用binwalk分析发现这不仅仅是一张图片，还有压缩包，包里面有个文本文本需要密码打开，根据文件名猜想应该是四位数字密码，暴力破解成功flag{vjpw_wnoei} 六、文件中的秘密这道题考查对StegSolve工具的使用，使用file format功能，发现了flag，接下来就是把这个flag进行规矩处理即可当然，用010editor也可以，只不过搜的时候不要搜flag，搜一个f慢慢看就能找到flag{870c5a72806115cb5439345d8b014396} 七、wireshark这道题主要考察对wireshark的使用，题目说密码就是flag直接用wireshark打开文件，之后，字符串搜索post（为什么搜索post？因为账号密码是post上去的，就这么将就地解释吧）一个个翻找后找到了密码flag{ffb7567a1d4f4abdffdb54e022f8facd} 八、qr扫二维码就出了flag{878865ce73370a4ce607d21ca01b5e59}"},{"title":"csapp-lab环境搭建及lab1wp","date":"2022-03-25T09:58:06.000Z","url":"/2022/03/25/csapp-lab%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8Alab1wp/","categories":[["undefined",""]],"content":"一.环境搭建** 首先要搞一个ubantu的虚拟机，具体自行百度搞好虚拟机开始搭建环境，右键打开终端，然后输入以下指令 如何做题及如何检查对错，输入以下指令（以第一道题bitXor为例） 得满分就说明做对了** 二.lab1wpint规则（百度翻译的，应该能看懂）整数常量0到255（0xFF），包括在内。不允许使用大常量，例如0xffffffff。明确禁止您： 1.使用任何控件构造，例如if、do、while、for、switch等。 2.定义或使用任何宏。 3.在此文件中定义任何附加功能。 4.调用任何函数。 5.使用任何其他操作，如&amp;&amp;、| |、-、or、？： 6.使用任何形式的铸造。 7.使用int以外的任何数据类型。这意味着无法使用数组、结构或联合。 1.bitxor 题意就是用~、&amp;来实现异或~：对于二进制的每一位，将1变为0，将0变为1 对于x，y，只能有两种&amp;组合，x&amp;y和x &amp; ~y，如果是 ~x&amp;y，或者是 ~y&amp;x，都是行不通，要么都取反，要么都不取这里就用4，5来尝试一下，4&amp;5=0100，4&amp;~5=1010（删除线无视即可，我也不理解怎么出的删除线）这下就是进行不断尝试组合，出答案 2.tmin 题意是求二进制补码的最小值，0x10000000是最小值，但是只能输入0到255（0xFF）之间的，所以要用到左移&lt;&lt;，具体如下： 3.isTmax 题意是如果接受的x为二进制最大值，就返回1，否则为0二进制最大值为0x7FFF FFFF，假设它就是x，则x+1就是0x8000 0000，这个时候将二者异或就得到了0xFFFF FFFF，再加一个 ‘~’ ，就得到了0,最后return时再用逻辑非即可。但是0xFFFF FFFF与其+1异或后也是0xFFFF FFFF，这个时候再对其+1的数两次 ‘!’，为0，结合一下进行与运算具体实现如下： 4.allOddBits 题意就是当所有奇数位为1时，返回1。满足所有奇数位为1的数只有0xAAAA AAAA和0xFFFF FFFF,这个时候就要用到异或来判断了首先假设x是0xAAAA AAAA，要弄出一个与x异或的值0xAAAA AAAA，这样使其为0后，再用逻辑非变成1，如果x为0xFFFF FFFF ，这里需要再多加一条与运算，使其先变为0xAAAA AAAA再异或就得到0了现在还有一个问题就是0xAAAA AAAA怎么给变量赋上值，这里就要用到逻辑左移和异或结合得到具体如下： 5.negate 题意就是取相反值这个还是要用到，对每一位，0变1，1变0就拿x=0xFFFF FFFF来说，x=0，0+1=1，再拿x=0x8000 0001来说，~x+1=0x7FFF FFFD +1=0x7FFF FFFF具体如下： 6.isAsciiDigit 题意就是如果0x30 &lt;= x &lt;= 0x39，则返回为1 也就是满足x-0x30&gt;=0&amp;&amp;x-0x39&lt;=0返回为1 这里x-0x39&gt;=0要改为x-0x3a&lt;0好表示,当然也可以0x39-x&gt;0 然后结合逻辑非’!’以及或运算 具体如下: 7.conditional 题意就是实现x?y:z即如果x为真 那么值就是y 否则就是z先将用两个逻辑非将不为0的变为1,为0的则还是0若x为真,则将其变为x=0xFFFF FFFF,这样有利于与运算时若不为真,则使用逻辑取反,将x=0变为0xFFFF FFFF具体如下: 8.isLessOrEqual/* isLessOrEqual - if x &lt;= y then return 1, else return 0 Example: isLessOrEqual(4,5) = 1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 24 Rating: 3 /题意:若x&lt;=y返回为1,否则为0首先先用异或和逻辑非判断x与y是否相等，相等则为1 若不相等,则x为负数，y为正数时，也就是x符号位为1，y的符号位为0时，我们可以试图让其返回为1 那先让x，y同时右移31为，此时x为0xFFFF FFFF，y为0，用逻辑非让x为0，再用或运算使x，y两者返回为0， 最后再用一个逻辑非让其为1。其实考虑的这种方法虽然只考虑了x为负数，y为正数，但是也同样适用y为负数，x为正数的时候 然后再考虑x与y符号位一致时，首先用异或判定符号位是否一致，然后此时只需用x+~y+1=x-y得到的数为0xFFFF FFFF，使用两个逻辑非将其变成1，然后给两者与运算 满足以上三种情况的任意一种就可以具体如下： 9.logicalNeg 题意：用上述的符号实现逻辑非让不为0的数变为0，让0变为1，想一想，0和他的相反数符号位都是0，而相反不为0的数和他的相反数符号位肯定有一个为1使用或运算得到-1最后再加上个1就满足了具体如下： 10.howManyBits 题意：判断输入的数有几位首先我们要对负数进行取反，正数该是什么就是什么，主要是为了方便判断位数这里要用到二分法，先判断是否有16位如果有，再判断是否有24位，否则就判断是否有8位，然后像这样8，4，2，1，0进行判断这里咱也不会讲，就直接上代码吧 float规则编码规则没有那么严格。您可以使用循环和 条件控制。您可以同时使用整数和无符号。 可以使用任意整数和无符号常量。你可以使用任何算术， 对整型或无符号数据执行逻辑或比较操作。 明确禁止您： 1.定义或使用任何宏。 2.在此文件中定义任何附加函数。 3.调用任何函数。 4.使用任何形式的铸造。 5.使用除int或unsigned之外的任何数据类型。这意味着你 无法使用数组、结构或联合。 6.使用任何浮点数据类型、运算或常量。 floatScale2 这张图片有点比较模糊，也请大家凑和看吧第一位是符号位，中间的8位是阶码，后面的23位是尾数s是符号位，M是尾数，E是阶码浮点数就分为这四类，规格化的是中间八位!=0&amp;!=255,后面任意非规格化的就是中间八位为0，后面任意值无穷大就是中间八位为0xFF，后面23位为0NaN跟无穷大的区别就是后面23位不为0 题意：返回传入的数的二倍无穷大和NaN返回值就是它本身规格化的就让它阶码+1就可以了，非规格化的就让它左移一位（比如二进制10左移就是100） 代码实现如下： floatFloat2Int 题意：将浮点型uf转换为int类型不会了。。。不理解23和31是怎么回事。。。只有搬来的代码 floatPower2 继续摆烂搬运代码如下： "},{"title":"滴水逆向笔记（四）","date":"2022-02-09T13:28:29.000Z","url":"/2022/02/09/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","categories":[["undefined",""]],"content":"1.通用寄存器：32位：EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 16位：AX,CX,DX,BX,SP,BP,SI,DI 8位：AL,CL,DL,BL,AH,CH,DH,BH 2.MOV语法： MOV 目标操作数 源操作数 作用：将源操作数拷贝到目标操作数 另外，还有如SUB、ADD、XOR、AND等等逻辑运算也运用到了 3.源操作数可以是立即数、通用寄存器、段寄存器或内存单元 4.目标操作数可以是通用寄存器、段寄存器或内存单元 5.操作数的宽度必须一样 6.源操作数和目标操作数不能同时为内存单元 7.从指定内存中写入数据的格式： mov dword（也可以是其他的·） ptr ds [0x0012FF34],0x12345678 mov eax ptr ds：[0x0012FF34] 具体如下图所示："},{"title":"滴水逆向笔记（三）","date":"2022-02-09T13:27:08.000Z","url":"/2022/02/09/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","categories":[["undefined",""]],"content":"​1.在计算机中由于受到硬件制约，数据是有长度限制的，所以在计算机中超过长度的数据就会被舍弃。 2.如下图所示，有符号数和无符号数 3.几个重要的计量单位 字节 1Byte = 8Bit 字 1Word =16Bit 双字 1DWord = 32Bit 4.逻辑运算 （吐槽：导论考试第一题就是这个，考试时就想着只要这个东西不出错分多低都不难受， 结果出考场一看，是我低估了，也不能说低估，就是还是自己学的不踏实） 其实通过下图电路图本质就已经很明了了 （1）或（or |） （2）与（and &amp;） （3）异或（xor ^） （4）非（not ！） 只能说这个确实简单了，若0则1，若1则0 5.CPU如何运算的？ 比如算5+4=？ 这里看图就可以了，设计这种算法的人真，确实鬼才 6.关于简单加密 主要就是利用异或算法进行加密​"},{"title":"攻防世界web新手练习区（1-12）","date":"2022-02-09T13:18:21.000Z","url":"/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA%EF%BC%881-12%EF%BC%89/","categories":[["undefined",""]],"content":"一.view source直接F12，可以看到flag:cyberpeace{3485c40fbf442a57c1ac6280af8070e7} 二、robots先在网址添加后缀robots.txt,会出现如下页面然后我们将后缀改为flag_1s_h3re.phpflag:cyberpeace{04cbb73c4d62a9cd327bb2faf9bbcfbf} 三、backup打开页面，问你知道index.php的备份文件吗，然后我们再加上后缀index.php.bak,此时下载文件打开下载好的文件，flag出现了flag：Cyberpeace{855A1C4B3401294CB6604CCC98BDE334} 四、cookie打开页面，按F12找cookie，如图此时可以在网址后缀加上cookie.php,出现如图页面，意思是查看http响应然后使用burpsuite进行抓包，查看http响应，如图可得flagflag:cyberpeace{b85003abf4d902f502cda1f75f393fb1} 五、disabled_button打开页面，按钮确实没法按，遇事不决F12看到有个disabled,心想改一下把disabled变成abled，按钮能按了，按一下如下所示flag:cyberpeace{96e4244aa3517089b882bbf29d9e593d} 六、weak auth打开是个登陆页面，我们随便输个用户名密码进去，如下，意思是请以admin登录然后用burpsuite进行抓包爆破，抓包时我们随便输入密码，然后进入测试器一栏，在密码55旁边添加§进入有效载荷，点击载入中选择字典，然后点击开始攻击通过长这一列来判断爆破是否成功，看到不一样的长，我们点击它，然后点击之后我们点击响应，看到了flag，当然也可以自己手动输入密码flag:cyberpeace{7caf75b6f189f19ee14008ac95003882} 七、simple php打开页面，发现跟传参有关，我们先传?a==0,得到如图所示发现是一半flag,我们看一下语句，这里注意：is_numeric() 函数用于检测变量是否为数字或数字字符串传入对应参数，得到完整的flagflag:Cyberpeace{647E37C7627CC3E4019EC69324F66C7C} 八、get post打开页面,让传递参数，照他说的做然后又让提交变量,这里直接用hackbar提交，得到flagflag:cyberpeace{d8b214b7f9ea4ff909293f0d4c05fb6a} 九、xff_referer先查下相关资料维基百科上对xff和referer的解释：X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP头字段。Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。简单地说，xff是告诉服务器当前请求者的最终ip的http请求头字段，通常可以直接通过修改http头中的X-Forwarded-For字段来仿造请求的最终ipreferer就是告诉服务器当前访问者是从哪个url地址跳转到自己的，跟xff一样，referer也可直接修改开始做题：打开页面，显示ip必须为123.123.123.123，开始抓包，在代理一栏，然后发送给Repeater，然后点击重发器，点击头，点击添加，之后添加如下所示，再点击发送从上图右边可以看到有一段话必须来自…，然后再次添加referer，如下图所示添加完点击发送，看到了flagflag：cyberpeace{e79f149f49a3503d622f0494bc630f3a} 十、webshell百度百科：webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，只需上传一个代码文件，通过网址访问，便可进行很多日常操作，极大地方便了使用者对网站和服务器的管理。正因如此，也有小部分人将代码修改后当作后门程序使用，以达到控制网站服务器的目的。 [1]顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作命令。webshell主要用于网站和服务器管理，由于其便利性和功能强大，被特别修改后的webshell也被部分人当作网站后门工具使用。 打开页面，直接用中国菜刀（这个也属于是一个webshell），然后右键添加，如下图所示添加好之后直接双击打开，页面如下打开flag.txtflag：cyberpeace{1d4d78cf4b8f02604295835ba209fd72} 十一、command execution先了解相关知识PING:：Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。ls命令：命令：开始做题：先使用搜索命令查找是否有flag.txt这一文本ping一下，如图所示，找到了flag.txt之后用cat命令打开文本ping一下，出现了flag：cyberpeace{50da66af3eac110a4eaf116169f0286e} 十二、simple js打开页面，是个输密码的页面，直接点确定，然后进入一个空白页面，这时直接查看页面源代码，发现有东西这个看起来好像url解码，这里将\\x换成%，然后使用url解码，解出来一堆数字，此时对照ASCII码表进行解密，解出来786OsErtk12flag：Cyberpeace{786OsErtk12}"},{"title":"滴水逆向笔记（二）","date":"2022-01-12T13:41:00.000Z","url":"/2022/01/12/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","categories":[["undefined",""]],"content":"1.在什么情况下满足2+3=1？ 其实这个无非就是自己定义一个进制，就比如自己定义一个十进制，进制中的元素可以是随机的， 按顺序来0，2，3，1，6，4，5，9，7，8；这个就满足2+3=1 2.进制并不是死的，就像365进制也是存在的，多少进制都是存在的，这时候思维应该要放灵活的 3.假如定义一个三进制，由2，0，1组成； 2 0 1 02 00 01 12 10 11 11+2（往后移两位的意思）=020 11+2（这里是进制中的2）=022 4.通过这种咋一眼看起来很没有逻辑的进制，我们可以搞一种这种类型的进制加密，也是其意义之一了"},{"title":"滴水逆向笔记（一）","date":"2022-01-12T09:51:46.000Z","url":"/2022/01/12/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"#第一篇博客 1.进制：几进制就逢几进一，十进制逢十进一，二进制逢二进一 几进制中有几个数字，十进制有0，1，2，3，4，5，6，7，8，9这十个数字，二进制有0，1两个数字 十六进制有1，2，3，4，5，6，7，8，9，A,B,C,D,E,F； 二进制对应的为0001，0010，0011，0100，0101，0110，0111，1000，1001，1010(A)，1011(B)，1100(C),1101(D),1110(E),1111(F) 2.二进制 计算机上的所有文件都是以二进制方式存储的，且受硬件制约，只能用二进制，另外，二进制足够表示了 3.一句经典的话：进制之间不需要转换，每个进制都是最完美的进制 4.计算方法本质上就是查出来的 十六进制下： 15+5=15+1+4=24； 5*4=5+5+5+1+4=24；————————————————版权声明：本文为CSDN博主「瑟瑟发dou的小怪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"Hello World","date":"2022-01-12T06:07:38.312Z","url":"/2022/01/12/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]