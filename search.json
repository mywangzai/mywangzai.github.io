[{"title":"BUUCTF RE（部分题解）","date":"2022-08-02T03:05:02.000Z","url":"/2022/08/02/BUUCTFRE%EF%BC%88%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%89/","categories":[["undefined",""]],"content":"前言：我比师傅们的逆向都学的拉，所以我只能从buu开始学习基础呜呜 xorshift+F12字符串窗口然后F5反汇编看源代码 分析一下，该题是输入flag到v6，v6中数组前一项跟后一项进行异或运算赋给前一项然后我们需要找一下global到底代表什么，我们点进去看一下这并不是，我们再点进下面这串编码，这些字符串就是global接下来写脚本，运行就能出flag 这里记录几个函数（我菜鸡python不会但是还想用。。。）isinstance(object, classinfo) object是值,classinfo是类型，例如isinstance(1,int)返回的就是true，isinstance(1,str)返回的就是false chr():chr函数来返回指定字符码所代表的字符，跟ASCII码有关。 比如chr(65)返回的就是大写字母Aord():这里我简称逆chr()，就比如ord(‘A’)返回的就是65 helloword这道题是一道基础的apk逆向使用APKIDE打开，找到主函数，里面就有 reverse31.先打开反汇编看源代码2.点进去sub_4110BE函数查看，base64(其实真要说清楚我也说不清楚)，点进去aAbcdef 那一串看一下，知道这就是base64编码表 3.查看一下主函数的str2是什么这时候我们就有思路了，首先是先输入一串字符串也就是str，然后将这些字符串经过base64加密赋给v4，再将v4赋给Dest，再给Dest的每个字符后面加上下标值，最后判定Dest与str2是否一样，一样返回”right flag“根据这个思路我们写脚本 不一样的flag(这道题我还不配深挖，只能先浅讲一下，记一下题型)用IDA打开，打开字符串窗口，发现第一行是个奇怪的字符串，先记住它我们还是照例看反汇编代码 再看这个*11110100001010000101111#，一共25个字符，wp上说的是迷宫，确实是迷宫，但是我感觉我讲不透，不过还是把我明白的都详细地说一下 看上面的代码，v8这个变量只声明了，没有赋值，上面标注了v8在堆栈中是[esp+40h],但是最后又减了个十进制的41，转成十六进制就是0x29，40h-29h=17h，也就是说最后得到的是[esp+17h],而v3对应的就是[esp+17h]。说这么多就是找一下v3和v8的关系。迷宫就是这样子，就像上面注释的那样走就行 也就是222441144222，当然走完迷宫他并没有给flag，那就直接把这个’行走路线’当成flag输进去就是对的 SimpleRev先看跟字符串有关的函数(加了点小小的注释) 然后看关键加密的一段代码 也就是根据这些加密条件把v1逆出来，写python脚本爆破一下(他们都这么说哈哈) 倒写具体看心得部分，虽然说的也很简单吧哈哈 Java逆向解密这个后缀class的文件需要用Java Decompiler打开，打开后代码如下 我们挑出核心代码 要让Resultlist与KEYList一样，而result就是输入的字符串+‘@’^0x20 这样加密过后的添加到Resultlist，这时候还是要用到爆破思想写python脚本 [GXYCTF2019]luck_guy这道题写的纯属主观臆测，直接看主要函数 当时没想这么多，点进去f1有赋值，f2没有，直接从以下代码里猜测出f2。首先是case4，f2=f2+s，得到f2=’icug`of ‘，这个case5肯定不是等闲之辈，肯定是把f2又加密了，加密过后的f2才是case1里真正的f2 根据case5代码直接写脚本 不知为何，脚本的最后输出有点小问题，不过也不耽误事，就当右花括号就可以了 心得：先浅浅的总结以下出现的一个最大问题就是十进制转化为倒序字符串倒叙字符串就是当它数据类型是int64什么的它就是倒序的，用的时候需要把它顺序颠倒回来当然并不是转化过程中都是倒序的，char类型的就是正常顺序，可以直接用接下来都是废话了，吐槽的就做SimpleRev这道题，看到strcat(key,src)，当时我也没见过这个函数，就去查，去小熊猫试了老大会这个函数都是正常字符串连接顺序，看到用strcat连接key+src，特别纳闷大佬的wp为什么最后src又倒序，大佬最后也没说。最后做到luck guy看到大佬的wp提到这个问题才算是茅塞顿开，反正我也不喜欢太深究，也不想知道里面究竟有什么知识点，累了 [BJDCTF2020]JustRE这道题说难也很简单，说简单也特别难，想完完全全弄会这道题就很难，靠猜测推断的话就很简单，我是后者哈哈1 首先ida打开跟进字符串窗口2 然后反汇编看源代码，看19999那块，点进sprintf里面的aBjdDD…看一下3 大胆猜测%d%d指的就是19999和0，尝试一下就是正确flag如果尝试跟进spintf函数，里面很复杂，也懒得看了flag{1999902069a45792d233ac} 刮开有奖这道题也说起来是比较难的一道题了，不是真会，借鉴了大佬的wp，勉强算会了1 首先ida打开字符串窗口跟进这个可疑字符2 F5看反汇编代码 3 先看一下给v9加密的sub_4010F0这个函数 可以将这个代码化为c语言代码运行，原来代码右键隐藏casts，把(_DWORD )这个汇编标记隐藏掉，最重要的一点来了，可以看到下面c代码a1 + 4 * result，v5 = 4 * i;表达式里面的”4“没有了，这也是从大佬wp收获的重要的东西，原因是int占四个字节，所以需要*4，如果是char类型则不需要 运行出来是这样的，也就是v9[]=’3CEHJNSZagn’4 再看后面的这个sub_401000函数， 虽然看着确实摸不着头脑，但是细心观察47和58行，点进65行的byte_407830看一下是base64编码表，不过差了个’A’，41h就是’A’，太坏辣出题人分析这么多我也就分析出个base64加密接下来再看这两行代码，效果也就是把v6和v7base64加密了一下 最后看关键加密代码，v21,v22,v23就是String里面的，因为String是[esp+30h],v21是[esp+31h]v22是[esp+32h]，v23是[esp+33h] 最后拼接在一块是’UJWP1jMp’，因为前面已经有了’WP’，所以v7肯定在前面，v6在后面 简单注册器思维难度不算难，就是没接触过相关知识首先文件是apk安装包，这里要用到JEB来对其进行反汇编，用JEB打开文件后，需要按Tab看反汇编java代码找到核心加密代码，也就是对v5做了一系列变化，变化后的v5就是 根据这个写脚本，python学的太拉了，所以特地给自己注释了一下 输出的即为flag [GWCTF 2019]pyre文件是pyc后缀，反编译后就是py，可以使用在线pyc反编译也可以在ubantu里执行如下命令 反汇编出来的代码如下 根据代码写脚本 运行脚本生成flag [ACTF新生赛2020]easyre查壳，发现是UPX，那就先脱壳脱完壳用ida打开，进入到main函数，F5反汇编 这道题我被迷惑了很大一阵子，主要原因是被v16+i给迷住了，我以为v16+1=v17,像这种编号问题真的不该犯。应该根据ida给的注释来说，比如v16是在[esp+1E],而v17是[esp+22]，差四位。接下来总体分析一下，就是输入值赋给v19，主要是v23，v24，v25对应的数对应byte_402000数组中的编号，然后跟v4数组里面的数进行比较，除了ACTF{}，还有12位字符待输入。看一看byte_402000对应的表接下来写脚本 得到flag rsa这道题确实一点不会，纯看大佬的wp，只是尝试复现(虽然复现也没能复现出来)首先记事本打开，然后复制，在线rsa公私钥解析e=65537(指数)n=86934482296048119190666062003494800588905656017203025617216654058378322103517 (模数转十进制) 然后在线质因数分解，分解出p，qp=285960468890451637935629440372639283459q=304008741604601924494328155975272418463脚本就跟我没关系了，纯纯搬运参考链接: [ACTF新生赛2020]rome先看主要加密函数的反汇编 这里说两句废话，不出所料的话，先给出的v5,v6,v7,v8,v9,v14应该就是flag的前后缀 接下来就不说废话了，v1v4以及v10v13之间都可以存储16个数据，后面就是它给它拷贝一下，然后加密，加密过后跟v15~v30作比较，相同就是flag看核心加密代码 这道题要用爆破思想，这里我想错了，结果写的脚本也就错了 正确：先写正确的脚本 正确的运行结果 错误：错误的脚本也写出来，刚开始没想着用爆破思想，就是想着硬推，结果交上去不对纳闷了半天 错的就是这样虽然脚本错了，但是可以修正正确(虽然跟爆破比确实有点麻烦)，不过我也摸不清到底怎么回事。。。 根据这个修正后的脚本我们可以知道一点原因，就比如说输出错误的’X’,就是说(88-79)%26=(114-79)%26=9，错的原因就是没有考虑到小写字母加密还是小写，大写字母加密还是大写，吃了取余的亏，所以能爆破尽量不要硬逆 CrackRTF新题型不咋会，草草地看了大佬的wp这里我写的也是最懒蛋的写法，得益于这个网站，直接用网站解出这两段md5也就是 结合反汇编代码可知，两次输入的密码，第一次是123321，第二次是 !3a@0 将exe文件拖入cmd运行，然后就会自动生成一个rtf文件更详细的看这位大佬的[wp](^v31^pc_rank_34,185^v2^control&amp;spm=1018.2226.3001.4187) [FlareOn4]login 1.用记事本打开html文件 2.看关键加密代码 主要意思就是如果c&lt;=”Z”就是90大于就是122，然后90或者122如果&gt;=(c=c+13),就为c否则就是c-26也就是说如果输入的字符中(AM&amp;am)中的字符加13，(NZ&amp;nz)中的字符减13根据if (“&#80;&#x79;&#118;&#x72;&#x61;&#x67;&#x46;&#x76;&#x71;&#x72;&#89;&#x62;&#x74;&#x76;&#97;&#x66;&#78;&#x65;&#x72;&#82;&#110;&#102;&#x6c;&#64;&#115;&#x79;&#x6e;&#101;&#x72;&#x2d;&#98;&#x61;&#x2e;&#x70;&#98;&#x7a;“ == rotFlag) { alert(“Correct flag!”); }可以写脚本 运行结果 [GUET-CTF2019]re先脱壳，用吾爱的脱壳没找到合适的，用kali自带的，可以看到还是64位看反汇编 然后我们看20行的sub_4009AE，需要满足返回为true，点进去看看这个函数 这道题出的有点马虎，a[6]的值都不给，有大佬直接爆出来了为1，直接写脚本，抄大佬的 。^ 。 [2019红帽杯]easyRE用ida看反汇编 先把v53解出来，给我们提示说flag前四位是”flag” 然后接着看sub_400E44这个函数很明显是base64加密，而且还加密了10次，那就把off_6CC090里面的数据解码10次 看一下off_6CC090里面的数据后面有省略号，说明不止这些，再点进去看看，也是能经得起10次加密的长度了写个脚本 结果是一个网站他真的很擅长主动防御看来这个函数坑小孩的，mad，根据提示我们知道前四位是flag，然后这串字符串很可疑，跟进调用它的函数，看反汇编 102，103对应的ascii码是’f’,’g’，这个应该是了，后面这个加密不是太明白HIBYTE()是取最后一个字节，v6的求法也就是让byte_6CC0A3与’flag’进行异或逆出来v6，然后v6再跟byte_6CC0A0异或得到v0 写脚本 [WUSTCTF2020]level11.首先看main函数反汇编 2.这是涉及到了输入输出流吧(其实我也不懂)，文件中还给了一串数字3.根据这一串加密的我们逆出来解密过程，可以发现数组中的第一个元素没有使用，那我们逆的时候在数组中最前面要添上一个数，随便什么都可以 4.脚本 [MRCTF2020]Transform1.看main的反汇编 2.看主要加密代码，主要意思就是输入的字符数组的第（dword_40F040[i]-1）个元素赋给byte_414040[i]，然后再让byte_414040[i]与dword_40F040[i]进行异或加密最后跟aGyURsywBFbLwya这个数组进行比较（这些数组都可以点进去查看） 3.写脚本 [WUSTCTF2020]level21.upx的壳，用kail自带的脱壳 2.用ida打开看main函数，发现直接有flag [ACTF新生赛2020]usualCrypt1.ida看main函数的反汇编代码 2.然后我们看sub_401080，当时以为就纯纯base64，大意了 3.然后再点进sub_401000看一下，其中byte_40E0AA是base64编码表中的K/byte_40E0A0是AJ，这里函数起到的作用就是让GHIJKLMNOP与QRSTUVWXYZ交换位置 4.返回上一级代码看最后一行函数sub_401030，很明显，小写换大写，大写换小写 5.最后就是我们输入的flag经过base64【改】加密与byte_40E0E4 6.写脚本的时候就可以直接用byte_40E0E4进行base64【改】解码，我就直接抄大佬的base64c语言解码 7.运行结果 Youngter-drive文件需要先脱壳，同样都是UPX的壳，老办法就可以了1.首先ida打开看main函数反汇编 这里有个新知识点CreateThread()创建线程，这里调用了两次，调用A再调用B，调用B完了之后再调用A，交替执行，顺序这方面不确定2.先看StartAddress里面的 点进这个sub_41112C看一下这个是堆栈不平衡，解决办法就是找到这个函数，光标放到pop ebp，然后Alt+K把0x4改成0改好之后直接F5就可以看到反汇编代码了 也就是说这个就是将(a1+a2)数组中的大写字母-38，小写字母-96，其对应的十进制是off_418000中对应字符串的位置，然后将这个字符赋给a1+a2简单来说，就是将原来字符串的字母替换为 off_418000中的字符，大写的字符转成 off_418000中的小写，小写的字符转成 off_418000中的大写字符3.接着我们看另一个线程的，也就是sub_41119F 对dword_418008变量进行减1操作4.最后再看sub_411190，也就是加密过后的Source[i]与off_418004[i]进行比较 5.由于这两个线程是交替执行的，而且咱们也不知道谁先执行谁后执行写脚本 字符串长度是29，而dword_418008是0x1D，从1D~0总共是30，字符串长度应该是30，最后一个字符不知道是哪个字母，就随便试，试出来是E [HDCTF2019]Maze1.文件有UPX壳，kali或者其他脱壳软件应该都可以，这里不再过多赘述了然后用ida32位打开，看着是main函数，然后按F5没反应 这个jnz要跳到call这里，然而这个call的也不是个正确的地址，这个jnz为花指令，直接nop怎么nop呢?首先光标在jnz那里，找到图下这个单字节修改(ida不汉化应该也是这个位置)，然后75 01都改成90，0x90也就相当于nop改好之后再来看这个call，先按D转成数据这个0xE8也相当于call的操作码，就把它nop了（实际上是把这每一个数据先nop一个，反汇编还是不行就把下一行也nop），把E8改成90即可改好之后按c再转为代码然后直接在像这种红色片段的找到第一个红色部分，按P相当于创建函数这个时候就直接F5，(这个花指令离不开学长的教诲，由于本人脑袋迟钝，学长费了好大功夫才让我明白怎么做)看到这个代码就好分析了，这个asc_408078初值为7，dword_40807C初值为0，然后通过输入wsad相关指令进行14次位移，最后满足asc_408078为5，dword_40807C为-4最后找这个迷宫，大佬wp说在内存中找，那就shift+F12找字符串，这个很明显点进去然后选中这一串然后shift+E，如图所示，这个迷宫可以直接走我们看到0x2B也就是迷宫入口坐标是(7,0),也就是说出口点是(5,-4)也就是说wsad对应的操作就是上下左右(不反4399设计，很好)正好走14步flag也就是ssaaasaassdddw😔，废物两天才写了这么一道题 相册一道安卓逆向先用jadx-gui打开看这道题的描述找邮箱就可以了，那我们先搜mail我们点进第一个看一下，从mailto这个可以理解为就是发给某个邮箱，而且看这个方法里面还给提示字符串successsfully，failed判定输入的对不对那我们再来搜一下这个方法，看谁调用了它点进第二个看一下我们要找到这个mailto，再搜一下这个MAILSERVER点进第一个看一下，base64解密后调用的再搜一下点进最后这个看一下这个时候我们就要知道这个native什么意思可以参考一下这两篇博客：这个native方法实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中，这个文件就常常是 loadLibrary导入存在源文件目录下的.dll/.so文件 由于我才疏学浅，不知道这个文件用jadx怎么打开所以就换APK改之理打开的打开文件夹就可以看到了刚刚说了，这种文件一般是c/c++编写的，所以我们用IDA打开直接搜字符串咱们点进去就直接复制用base64解码就可以了，第二个字符串出现的邮箱就是咱们需要的了flag{&#x31;&#x38;&#x32;&#49;&#56;&#x34;&#x36;&#53;&#49;&#50;&#53;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;} [FlareOn3]Challenge1 用IDA打开文件，找到main函数直接F5 虽然看着复杂，但是其实就一base64换表加密，点进sub_401260看一下 看一下这个编码表byte_413000 最后要说明的一点是，这里的-2不用管，无视即可 结果（不得不说这个网站真好用，之前做的跟这一样换表加密题，我还苦苦搜base64解码脚本，然后把脚本里面的编码表又换了再解，太狼狈辣） [WUSTCTF2020]level3这道题可真的太坏辣，毕竟没做过这么样的首先ida打开，main函数反汇编 这道题看着就一纯纯base64解码题，但其实把这个字符串base64解密过后不对，里面也没说base64换表，但其实确实是这样的点进看一下确实妹说换表点进base64_table，正常表但当我们选中base64_table，Ctrl+X看一下谁还调用了，好家伙点进这个LookAtYou看一下，F5反汇编 果然它搞的鬼，把表中前十个跟后十个换了一下，还是颠倒顺序换的写脚本 运行 PE这道题是学长给我们出的题，buu貌似没有下载:密码:0000这个文件ida打开没有东西，也不是UPX壳需要用010Editor打开然后需要将E0改成F0，原因可以看这篇博客链接就是E0指向NT文件头这个NT文件头也就是PE可以在图中看到是在F0区域，所以我们需要把E0改成F0改好之后就可以用ida打开了搜main函数看其反汇编 主要看这些，str是我们输入的，然后经过sub_411339加密得到v7，然后再让sub_4114B0(v7)返回1就可以了 首先我们先看sub_411339很明显是类似base64加密，然而我们再看一下这个编码表 换表了，然后我们再看sub_4114B0 很明显，字符串比较，那我们只需要进行base64【改】解码 [SUCTF2019]SignIn这道题本来是感觉麻烦，没想写，但是做完后感觉还是有很多东西值得记录用IDA打开然后main函数反汇编 这里为了方便做题，改了一下部分函数和变量名称这里的ASCII函数点进去 这个也没实力研究，记住是个16进制转ASCII码就可以了然后返回主函数看后面，这里有几个函数可以说一下__gmpz_init_set_str(rop,str,base):将 str 字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存 __gmpz_powm(rop,base,exp,mod): 计算 base 的 exp 次方，并对 mod 取模，最后将结果写入 rop 中 __gmpz_cmp(a,b)：a与b字符串比较，一样则返回0，否则为1其实这道题跟RSA有密切关系这是我根据反汇编整理出的，其中p，q用这个网站解的 现在我们主要是求m，直接上脚本(py大佬的) [MRCTF2020]hello_world_go这道题是用go语言写的，IDA版本够高这道题就很简单，我用的7.5的，搜字符串就搜不到7.6的好像就能直接搜到，这个对于能看懂go语言的应该没啥难度 [FlareOn4]IgniteMe这个主要是学习的是动调1.首先ida打开文件，打开字符串窗口，然后点进，之后反汇编 WriteFile在这里相当于printf再看sub_4010F0(NumberOfBytesWritten) 最主要还得看sub_401050() 搞一下v4，直接ida动调就可以了，先在v4那块下断点然后点三角开始动调，先F5然后随便往程序输入字符回车，然后F8单步执行，点进v4，可知v4=4接下来就是异或，字符串比较，接下来就直接写脚本c++初学，尝试了一下 [WUSTCTF2020]Cr0ssfun这道题没什么思维难度首先看反汇编 也就是让if判定成立就可以，点进去就会发现 就直接对着解对应的ASCII码就可以了 flag：wctf2020{cpp_@nd_r3verse_@re_fun} [FlareOn6]Overlong打开反汇编 看一下sub_401160 再看sub_401000，这个加密函数有点复杂 但是这道题你会发现，没有让我们向程序中输入字符运行程序也是只有一个弹窗，当然它也没壳，只不过这个弹窗好像是有什么东西还没告诉我们回过头看加密这一行 我们再看unk_402008，已经要大于28了，说明28这块应该是一个比较大的数 我在这里下了个断点然后动调也就跟着运行到这里，0x1C就是28那我们先用OD看一下把这一块改成AF，因为总共有0xAF个数据但是改完程序没法运行，这个时候我们就要用到010Editor，搜1C然后把1C改成AF保存运行 疑惑：为什么不能直接改？用010Editor改过的程序再用OD打开可以看到这里是push -0x51 [UTCTF2020]basic-reflag [BJDCTF2020]BJD hamburger competition首先下好文件，映入眼帘的是老八汉堡店然后我玩了一会发现并没有什么可以触发flag的东西我们需要知道Unity3D一般是C#写的，这个东西反汇编用的是ILSpy反汇编BJD hamburger competition_Data\\Managed\\Assembly-CSharp.dll一般C#需要反汇编的都是这么个路径然后File-&gt;Save Code到一个空文件夹双击即可查找线索字符然后我们需要先sha1解密str，然后md5加密str=1001但就在md5加密这里就出现了问题会发现这些交哪个都不对需要看一下这里md5加密的方法 ToString(“X2”)是告诉我们是需要大写的看最后一行，搜一下Substring()也就是说只需要20个字符flag{B8C37E33DEFDE51CF91E1E03E}"},{"title":"re部分题解","date":"2022-08-02T03:03:48.000Z","url":"/2022/08/02/re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","categories":[["undefined",""]]},{"title":"C语言实现base64加密","date":"2022-04-28T11:52:00.000Z","url":"/2022/04/28/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E5%8A%A0%E5%AF%86/","categories":[["undefined",""]],"content":"一.程序目的使用c/c++完成以下下算法: 输入一个字符串，检查该字符串总ascii码值。如果值大于1000则对该字符串进行base64加密输出，否则该字符串与base64编码表进行异或输出 二.程序代码代码如下： 三.程序分析1.这里先说一下base64加密 通常一个字节是8位，而base64加密是使这些8位的变为6位，就比如说“ABC”对应的二进制： 01000001 01000010 01000011 转为六位就是：（010000） （010100）（001001）（000011） 而正是其最多只有六位，2的6次方=64，base64由此得名，且base64编码表中总共有64个字符，如下表 通过上表，base64加密“ABC”得：QUJD 若有两个字符，比如“12”的二进制：00110001 00110010 转为六位一组就是 001100 010011 001000（不够自动补0） 本来按这样的规律base64加密是：MTI 但像这种2%3=2的字符串长度，需要再补上‘=’，也就是最后的加密结果是：MTI= 若字符串长度为1，也就是1%3=1，需要在加密过后再补上两个‘=’； 2.代码分析 这一段主要是初始化数组，输入字符串并计算字符串的ASCII值 这一段是对输入的字符串进行base64加密 for循环理论不知道该咋说，只能举个栗子， 比如输入ABC，对应的二进制也就是：01000001 01000010 01000011，让第一组二进制左移两位，也就是010000，得到第一组六位base 010000； 然后再让01000001与0x3（也就是11）进行与运算，也就把01000001的后两位提出来，然后左移四位也就得到010000，就是第二组base的前两位，再与右移四位的01000010（即0100）进行或运算，得到第二组六位base 010100； 第三组base就是让01000010&amp;0xf（也就是1111）得到0010接着左移两位得到001000，01000011右移两位得到01，001000|01得到第三组base 001001； 第四组base就01000011&amp;0x3f（也就是111111）得到000011 添加‘=’的这段代码，我也不会讲，也只能举个栗子 比如输入的字符串是‘1’，经过for循环之后，i的值为4，也就是y数组长度为5，但是从y[i-2]的值就是空的，所以添加‘=’要从y[i-2]开始赋值，由于y[i]里面没有存储值，所以数组长度就是4，而1%3=1，也符合上面的代码（感觉讲的好乱，不过我确实尽力了QAQ） ASCII值大于1000，作base64加密并输出 ASCII值小于1000，原字符串与base64编码表进行异或运算并输出 四.运行结果及验证程序运行结果： 在线base64加密验证： "},{"title":"BUUCTF MISC（随机基础八道题）","date":"2022-04-09T08:44:39.000Z","url":"/2022/04/09/BUUCTFMISC/","categories":[["undefined",""]],"content":"一、你竟然赶我走下载后是一个图片，直接用010editor打开，ctrl+F搜索flag，然后就出来了flag{stego_is_s0_bor1ing} 二、N种方法解决文件是一个exe，但无法打开，用010editor打开发现是base64转图片类型的字符串，这时可以直接复制这些东西用浏览器去打开也可以搜base64在线转换图片，得到的结果与上图一致，扫一下就出了flag{dca57f966e4e4e31fd5b15417da63269} 三、乌镇峰会种图直接用010editor打开，一搜flag就搜出来了 四、大白题目都说了图片小，那就把它调大些，这里把01改成08打开图片，得到flagflag{He1l0_d4_ba1} 五、二维码这道题主要考察对binwalk分离工具的使用用binwalk分析发现这不仅仅是一张图片，还有压缩包，包里面有个文本文本需要密码打开，根据文件名猜想应该是四位数字密码，暴力破解成功flag{vjpw_wnoei} 六、文件中的秘密这道题考查对StegSolve工具的使用，使用file format功能，发现了flag，接下来就是把这个flag进行规矩处理即可当然，用010editor也可以，只不过搜的时候不要搜flag，搜一个f慢慢看就能找到flag{870c5a72806115cb5439345d8b014396} 七、wireshark这道题主要考察对wireshark的使用，题目说密码就是flag直接用wireshark打开文件，之后，字符串搜索post（为什么搜索post？因为账号密码是post上去的，就这么将就地解释吧）一个个翻找后找到了密码flag{ffb7567a1d4f4abdffdb54e022f8facd} 八、qr扫二维码就出了flag{878865ce73370a4ce607d21ca01b5e59}"},{"title":"csapp-lab环境搭建及lab1wp","date":"2022-03-25T09:58:06.000Z","url":"/2022/03/25/csapp-lab%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8Alab1wp/","categories":[["undefined",""]],"content":"一.环境搭建** 首先要搞一个ubantu的虚拟机，具体自行百度搞好虚拟机开始搭建环境，右键打开终端，然后输入以下指令 如何做题及如何检查对错，输入以下指令（以第一道题bitXor为例） 得满分就说明做对了** 二.lab1wpint规则（百度翻译的，应该能看懂）整数常量0到255（0xFF），包括在内。不允许使用大常量，例如0xffffffff。明确禁止您： 1.使用任何控件构造，例如if、do、while、for、switch等。 2.定义或使用任何宏。 3.在此文件中定义任何附加功能。 4.调用任何函数。 5.使用任何其他操作，如&amp;&amp;、| |、-、or、？： 6.使用任何形式的铸造。 7.使用int以外的任何数据类型。这意味着无法使用数组、结构或联合。 1.bitxor 题意就是用~、&amp;来实现异或~：对于二进制的每一位，将1变为0，将0变为1 对于x，y，只能有两种&amp;组合，x&amp;y和x &amp; ~y，如果是 ~x&amp;y，或者是 ~y&amp;x，都是行不通，要么都取反，要么都不取这里就用4，5来尝试一下，4&amp;5=0100，4&amp;~5=1010（删除线无视即可，我也不理解怎么出的删除线）这下就是进行不断尝试组合，出答案 2.tmin 题意是求二进制补码的最小值，0x10000000是最小值，但是只能输入0到255（0xFF）之间的，所以要用到左移&lt;&lt;，具体如下： 3.isTmax 题意是如果接受的x为二进制最大值，就返回1，否则为0二进制最大值为0x7FFF FFFF，假设它就是x，则x+1就是0x8000 0000，这个时候将二者异或就得到了0xFFFF FFFF，再加一个 ‘~’ ，就得到了0,最后return时再用逻辑非即可。但是0xFFFF FFFF与其+1异或后也是0xFFFF FFFF，这个时候再对其+1的数两次 ‘!’，为0，结合一下进行与运算具体实现如下： 4.allOddBits 题意就是当所有奇数位为1时，返回1。满足所有奇数位为1的数只有0xAAAA AAAA和0xFFFF FFFF,这个时候就要用到异或来判断了首先假设x是0xAAAA AAAA，要弄出一个与x异或的值0xAAAA AAAA，这样使其为0后，再用逻辑非变成1，如果x为0xFFFF FFFF ，这里需要再多加一条与运算，使其先变为0xAAAA AAAA再异或就得到0了现在还有一个问题就是0xAAAA AAAA怎么给变量赋上值，这里就要用到逻辑左移和异或结合得到具体如下： 5.negate 题意就是取相反值这个还是要用到，对每一位，0变1，1变0就拿x=0xFFFF FFFF来说，x=0，0+1=1，再拿x=0x8000 0001来说，~x+1=0x7FFF FFFD +1=0x7FFF FFFF具体如下： 6.isAsciiDigit 题意就是如果0x30 &lt;= x &lt;= 0x39，则返回为1 也就是满足x-0x30&gt;=0&amp;&amp;x-0x39&lt;=0返回为1 这里x-0x39&gt;=0要改为x-0x3a&lt;0好表示,当然也可以0x39-x&gt;0 然后结合逻辑非’!’以及或运算 具体如下: 7.conditional 题意就是实现x?y:z即如果x为真 那么值就是y 否则就是z先将用两个逻辑非将不为0的变为1,为0的则还是0若x为真,则将其变为x=0xFFFF FFFF,这样有利于与运算时若不为真,则使用逻辑取反,将x=0变为0xFFFF FFFF具体如下: 8.isLessOrEqual/* isLessOrEqual - if x &lt;= y then return 1, else return 0 Example: isLessOrEqual(4,5) = 1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 24 Rating: 3 /题意:若x&lt;=y返回为1,否则为0首先先用异或和逻辑非判断x与y是否相等，相等则为1 若不相等,则x为负数，y为正数时，也就是x符号位为1，y的符号位为0时，我们可以试图让其返回为1 那先让x，y同时右移31为，此时x为0xFFFF FFFF，y为0，用逻辑非让x为0，再用或运算使x，y两者返回为0， 最后再用一个逻辑非让其为1。其实考虑的这种方法虽然只考虑了x为负数，y为正数，但是也同样适用y为负数，x为正数的时候 然后再考虑x与y符号位一致时，首先用异或判定符号位是否一致，然后此时只需用x+~y+1=x-y得到的数为0xFFFF FFFF，使用两个逻辑非将其变成1，然后给两者与运算 满足以上三种情况的任意一种就可以具体如下： 9.logicalNeg 题意：用上述的符号实现逻辑非让不为0的数变为0，让0变为1，想一想，0和他的相反数符号位都是0，而相反不为0的数和他的相反数符号位肯定有一个为1使用或运算得到-1最后再加上个1就满足了具体如下： 10.howManyBits 题意：判断输入的数有几位首先我们要对负数进行取反，正数该是什么就是什么，主要是为了方便判断位数这里要用到二分法，先判断是否有16位如果有，再判断是否有24位，否则就判断是否有8位，然后像这样8，4，2，1，0进行判断这里咱也不会讲，就直接上代码吧 float规则编码规则没有那么严格。您可以使用循环和 条件控制。您可以同时使用整数和无符号。 可以使用任意整数和无符号常量。你可以使用任何算术， 对整型或无符号数据执行逻辑或比较操作。 明确禁止您： 1.定义或使用任何宏。 2.在此文件中定义任何附加函数。 3.调用任何函数。 4.使用任何形式的铸造。 5.使用除int或unsigned之外的任何数据类型。这意味着你 无法使用数组、结构或联合。 6.使用任何浮点数据类型、运算或常量。 floatScale2 这张图片有点比较模糊，也请大家凑和看吧第一位是符号位，中间的8位是阶码，后面的23位是尾数s是符号位，M是尾数，E是阶码浮点数就分为这四类，规格化的是中间八位!=0&amp;!=255,后面任意非规格化的就是中间八位为0，后面任意值无穷大就是中间八位为0xFF，后面23位为0NaN跟无穷大的区别就是后面23位不为0 题意：返回传入的数的二倍无穷大和NaN返回值就是它本身规格化的就让它阶码+1就可以了，非规格化的就让它左移一位（比如二进制10左移就是100） 代码实现如下： floatFloat2Int 题意：将浮点型uf转换为int类型不会了。。。不理解23和31是怎么回事。。。只有搬来的代码 floatPower2 继续摆烂搬运代码如下： "},{"title":"滴水逆向笔记（四）","date":"2022-02-09T13:28:29.000Z","url":"/2022/02/09/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","categories":[["undefined",""]],"content":"1.通用寄存器：32位：EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 16位：AX,CX,DX,BX,SP,BP,SI,DI 8位：AL,CL,DL,BL,AH,CH,DH,BH 2.MOV语法： MOV 目标操作数 源操作数 作用：将源操作数拷贝到目标操作数 另外，还有如SUB、ADD、XOR、AND等等逻辑运算也运用到了 3.源操作数可以是立即数、通用寄存器、段寄存器或内存单元 4.目标操作数可以是通用寄存器、段寄存器或内存单元 5.操作数的宽度必须一样 6.源操作数和目标操作数不能同时为内存单元 7.从指定内存中写入数据的格式： mov dword（也可以是其他的·） ptr ds [0x0012FF34],0x12345678 mov eax ptr ds：[0x0012FF34] 具体如下图所示："},{"title":"滴水逆向笔记（三）","date":"2022-02-09T13:27:08.000Z","url":"/2022/02/09/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","categories":[["undefined",""]],"content":"​1.在计算机中由于受到硬件制约，数据是有长度限制的，所以在计算机中超过长度的数据就会被舍弃。 2.如下图所示，有符号数和无符号数 3.几个重要的计量单位 字节 1Byte = 8Bit 字 1Word =16Bit 双字 1DWord = 32Bit 4.逻辑运算 （吐槽：导论考试第一题就是这个，考试时就想着只要这个东西不出错分多低都不难受， 结果出考场一看，是我低估了，也不能说低估，就是还是自己学的不踏实） 其实通过下图电路图本质就已经很明了了 （1）或（or |） （2）与（and &amp;） （3）异或（xor ^） （4）非（not ！） 只能说这个确实简单了，若0则1，若1则0 5.CPU如何运算的？ 比如算5+4=？ 这里看图就可以了，设计这种算法的人真，确实鬼才 6.关于简单加密 主要就是利用异或算法进行加密​"},{"title":"攻防世界web新手练习区（1-12）","date":"2022-02-09T13:18:21.000Z","url":"/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA%EF%BC%881-12%EF%BC%89/","categories":[["undefined",""]],"content":"一.view source直接F12，可以看到flag:cyberpeace{3485c40fbf442a57c1ac6280af8070e7} 二、robots先在网址添加后缀robots.txt,会出现如下页面然后我们将后缀改为flag_1s_h3re.phpflag:cyberpeace{04cbb73c4d62a9cd327bb2faf9bbcfbf} 三、backup打开页面，问你知道index.php的备份文件吗，然后我们再加上后缀index.php.bak,此时下载文件打开下载好的文件，flag出现了flag：Cyberpeace{855A1C4B3401294CB6604CCC98BDE334} 四、cookie打开页面，按F12找cookie，如图此时可以在网址后缀加上cookie.php,出现如图页面，意思是查看http响应然后使用burpsuite进行抓包，查看http响应，如图可得flagflag:cyberpeace{b85003abf4d902f502cda1f75f393fb1} 五、disabled_button打开页面，按钮确实没法按，遇事不决F12看到有个disabled,心想改一下把disabled变成abled，按钮能按了，按一下如下所示flag:cyberpeace{96e4244aa3517089b882bbf29d9e593d} 六、weak auth打开是个登陆页面，我们随便输个用户名密码进去，如下，意思是请以admin登录然后用burpsuite进行抓包爆破，抓包时我们随便输入密码，然后进入测试器一栏，在密码55旁边添加§进入有效载荷，点击载入中选择字典，然后点击开始攻击通过长这一列来判断爆破是否成功，看到不一样的长，我们点击它，然后点击之后我们点击响应，看到了flag，当然也可以自己手动输入密码flag:cyberpeace{7caf75b6f189f19ee14008ac95003882} 七、simple php打开页面，发现跟传参有关，我们先传?a==0,得到如图所示发现是一半flag,我们看一下语句，这里注意：is_numeric() 函数用于检测变量是否为数字或数字字符串传入对应参数，得到完整的flagflag:Cyberpeace{647E37C7627CC3E4019EC69324F66C7C} 八、get post打开页面,让传递参数，照他说的做然后又让提交变量,这里直接用hackbar提交，得到flagflag:cyberpeace{d8b214b7f9ea4ff909293f0d4c05fb6a} 九、xff_referer先查下相关资料维基百科上对xff和referer的解释：X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP头字段。Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。简单地说，xff是告诉服务器当前请求者的最终ip的http请求头字段，通常可以直接通过修改http头中的X-Forwarded-For字段来仿造请求的最终ipreferer就是告诉服务器当前访问者是从哪个url地址跳转到自己的，跟xff一样，referer也可直接修改开始做题：打开页面，显示ip必须为123.123.123.123，开始抓包，在代理一栏，然后发送给Repeater，然后点击重发器，点击头，点击添加，之后添加如下所示，再点击发送从上图右边可以看到有一段话必须来自…，然后再次添加referer，如下图所示添加完点击发送，看到了flagflag：cyberpeace{e79f149f49a3503d622f0494bc630f3a} 十、webshell百度百科：webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，只需上传一个代码文件，通过网址访问，便可进行很多日常操作，极大地方便了使用者对网站和服务器的管理。正因如此，也有小部分人将代码修改后当作后门程序使用，以达到控制网站服务器的目的。 [1]顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作命令。webshell主要用于网站和服务器管理，由于其便利性和功能强大，被特别修改后的webshell也被部分人当作网站后门工具使用。 打开页面，直接用中国菜刀（这个也属于是一个webshell），然后右键添加，如下图所示添加好之后直接双击打开，页面如下打开flag.txtflag：cyberpeace{1d4d78cf4b8f02604295835ba209fd72} 十一、command execution先了解相关知识PING:：Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。ls命令：命令：开始做题：先使用搜索命令查找是否有flag.txt这一文本ping一下，如图所示，找到了flag.txt之后用cat命令打开文本ping一下，出现了flag：cyberpeace{50da66af3eac110a4eaf116169f0286e} 十二、simple js打开页面，是个输密码的页面，直接点确定，然后进入一个空白页面，这时直接查看页面源代码，发现有东西这个看起来好像url解码，这里将\\x换成%，然后使用url解码，解出来一堆数字，此时对照ASCII码表进行解密，解出来786OsErtk12flag：Cyberpeace{786OsErtk12}"},{"title":"滴水逆向笔记（二）","date":"2022-01-12T13:41:00.000Z","url":"/2022/01/12/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","categories":[["undefined",""]],"content":"1.在什么情况下满足2+3=1？ 其实这个无非就是自己定义一个进制，就比如自己定义一个十进制，进制中的元素可以是随机的， 按顺序来0，2，3，1，6，4，5，9，7，8；这个就满足2+3=1 2.进制并不是死的，就像365进制也是存在的，多少进制都是存在的，这时候思维应该要放灵活的 3.假如定义一个三进制，由2，0，1组成； 2 0 1 02 00 01 12 10 11 11+2（往后移两位的意思）=020 11+2（这里是进制中的2）=022 4.通过这种咋一眼看起来很没有逻辑的进制，我们可以搞一种这种类型的进制加密，也是其意义之一了"},{"title":"滴水逆向笔记（一）","date":"2022-01-12T09:51:46.000Z","url":"/2022/01/12/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"#第一篇博客 1.进制：几进制就逢几进一，十进制逢十进一，二进制逢二进一 几进制中有几个数字，十进制有0，1，2，3，4，5，6，7，8，9这十个数字，二进制有0，1两个数字 十六进制有1，2，3，4，5，6，7，8，9，A,B,C,D,E,F； 二进制对应的为0001，0010，0011，0100，0101，0110，0111，1000，1001，1010(A)，1011(B)，1100(C),1101(D),1110(E),1111(F) 2.二进制 计算机上的所有文件都是以二进制方式存储的，且受硬件制约，只能用二进制，另外，二进制足够表示了 3.一句经典的话：进制之间不需要转换，每个进制都是最完美的进制 4.计算方法本质上就是查出来的 十六进制下： 15+5=15+1+4=24； 5*4=5+5+5+1+4=24；————————————————版权声明：本文为CSDN博主「瑟瑟发dou的小怪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"Hello World","date":"2022-01-12T06:07:38.312Z","url":"/2022/01/12/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]